## 算法原理

**基数排序**（英语：Radix sort）是一种非比较型[整数](https://zh.wikipedia.org/wiki/整数)[排序算法](https://zh.wikipedia.org/wiki/排序算法)，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年[赫尔曼·何乐礼](https://zh.wikipedia.org/wiki/赫爾曼·何樂禮)在[打孔卡片制表机](https://zh.wikipedia.org/w/index.php?title=打孔卡片制表机&action=edit&redlink=1)（Tabulation Machine）上的贡献[[1\]](https://zh.wikipedia.org/wiki/基数排序#cite_note-1)。

它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

基数排序是非比较排序算法,算法的时间复杂度是O(n). 相比于快速排序的O(nlgn),从表面上看具有不小的优势.但事实上可能有些出入,因为基数排序的n可能具有比较大的系数K.因此在具体的应用中,应首先对这个排序函数的效率进行评估.

基数排序的主要思路是,将所有待比较数值(**注意,必须是正整数**)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次**稳定排序**(我们常用上一篇blog介绍的计数排序算法, 因为**每个位可能的取值范围是固定的从0到9**).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.

比如这样一个数列排序: 342 58 576 356, 以下描述演示了具体的排序过程(红色字体表示正在排序的数位)

第一次排序(个位):

3 4 2

5 7 6

3 5 6

0 5 8

第二次排序(十位):

3 4 2

3 5 6

0 5 8

5 7 6

第三次排序(百位):

0 5 8

3 4 2

3 5 6

5 7 6

结果: 58 342 356 576

两个问题:

- 为什么要从低位开始向高位排序?
- 为什么同一数位的排序子程序要使用稳定排序?

**这个算法的难度在于分离数位,将分离出的数位代表原元素的代表, 用作计数排序.但是分离数位不能脱离原来的数字,计数排序的结果,还是要移动原元素.**

**注意计数排序的元素数值与位置的联系,引申到基数排序的从元素得到中间值然后与位置的联系.**

## 算法图解

## javascript 代码

